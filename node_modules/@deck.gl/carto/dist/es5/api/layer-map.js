"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getLayer = getLayer;
exports.getColorAccessor = getColorAccessor;
exports.getSizeAccessor = getSizeAccessor;
exports.getTextAccessor = getTextAccessor;
exports.getTextPixelOffsetAccessor = getTextPixelOffsetAccessor;
exports._domainFromValues = domainFromValues;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _d3Array = require("d3-array");

var _d3Color = require("d3-color");

var _d3Scale = require("d3-scale");

var _d3Format = require("d3-format");

var _momentTimezone = _interopRequireDefault(require("moment-timezone"));

var _geoLayers = require("@deck.gl/geo-layers");

var _layers = require("@deck.gl/layers");

var _cartoTileLayer = _interopRequireDefault(require("../layers/carto-tile-layer"));

var _mapsApiCommon = require("./maps-api-common");

var _utils = require("../utils");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var SCALE_FUNCS = {
  linear: _d3Scale.scaleLinear,
  ordinal: _d3Scale.scaleOrdinal,
  log: _d3Scale.scaleLog,
  point: _d3Scale.scalePoint,
  quantile: _d3Scale.scaleQuantile,
  quantize: _d3Scale.scaleQuantize,
  sqrt: _d3Scale.scaleSqrt
};
var sharedPropMap = {
  color: 'getFillColor',
  isVisible: 'visible',
  label: 'cartoLabel',
  textLabel: {
    alignment: 'getTextAlignmentBaseline',
    anchor: 'getTextAnchor',
    color: 'getTextColor',
    size: 'getTextSize'
  },
  visConfig: {
    enable3d: 'extruded',
    filled: 'filled',
    opacity: 'opacity',
    strokeColor: 'getLineColor',
    stroked: 'stroked',
    thickness: 'getLineWidth',
    radius: 'getPointRadius',
    wireframe: 'wireframe'
  }
};
var RADIUS_DOWNSCALE = 0.2;
var defaultProps = {
  lineMiterLimit: 2,
  lineWidthUnits: 'pixels',
  pointRadiusScale: RADIUS_DOWNSCALE,
  pointRadiusUnits: 'pixels',
  rounded: true,
  wrapLongitude: false
};

function mergePropMaps(a, b) {
  return _objectSpread(_objectSpread(_objectSpread({}, a), b), {}, {
    visConfig: _objectSpread(_objectSpread({}, a.visConfig), b.visConfig)
  });
}

function getLayer(type, config, dataset) {
  var _config$columns;

  if (type === 'mvt' || type === 'tileset') {
    return getTileLayer(dataset);
  }

  var hexagonId = (_config$columns = config.columns) === null || _config$columns === void 0 ? void 0 : _config$columns.hex_id;
  var layer = {
    point: {
      Layer: _layers.GeoJsonLayer,
      propMap: mergePropMaps(sharedPropMap, {
        visConfig: {
          outline: 'stroked'
        }
      }),
      defaultProps: defaultProps
    },
    geojson: {
      Layer: _layers.GeoJsonLayer,
      propMap: sharedPropMap,
      defaultProps: _objectSpread(_objectSpread({}, defaultProps), {}, {
        lineWidthScale: 2
      })
    },
    hexagonId: {
      Layer: _geoLayers.H3HexagonLayer,
      propMap: mergePropMaps(sharedPropMap, {
        visConfig: {
          coverage: 'coverage',
          elevationScale: 'elevationScale'
        }
      }),
      defaultProps: _objectSpread(_objectSpread({}, defaultProps), {}, {
        getHexagon: function getHexagon(d) {
          return d[hexagonId];
        }
      })
    }
  }[type];
  (0, _utils.assert)(layer, "Unsupported layer type: ".concat(type));
  return layer;
}

function getTileLayer(dataset) {
  var _dataset$data$tiles = (0, _slicedToArray2.default)(dataset.data.tiles, 1),
      tileUrl = _dataset$data$tiles[0];

  var formatTiles = new URL(tileUrl).searchParams.get('formatTiles') || _mapsApiCommon.TILE_FORMATS.MVT;

  return {
    Layer: formatTiles === _mapsApiCommon.TILE_FORMATS.MVT ? _geoLayers.MVTLayer : _cartoTileLayer.default,
    propMap: sharedPropMap,
    defaultProps: _objectSpread(_objectSpread({}, defaultProps), {}, {
      pointRadiusScale: 0.3,
      lineWidthScale: 2,
      uniqueIdProperty: 'geoid',
      formatTiles: formatTiles
    })
  };
}

function domainFromAttribute(attribute, scaleType) {
  if (scaleType === 'ordinal' || scaleType === 'point') {
    return attribute.categories.map(function (c) {
      return c.category;
    }).filter(function (c) {
      return c !== undefined && c !== null;
    });
  }

  var min = attribute.min;

  if (scaleType === 'log' && min === 0) {
    min = 1e-5;
  }

  return [min, attribute.max];
}

function domainFromValues(values, scaleType) {
  if (scaleType === 'ordinal') {
    return (0, _toConsumableArray2.default)(new Set(values)).sort();
  } else if (scaleType === 'quantile') {
    return values.sort(function (a, b) {
      return a - b;
    });
  } else if (scaleType === 'log') {
    var _extent = (0, _d3Array.extent)(values),
        _extent2 = (0, _slicedToArray2.default)(_extent, 2),
        d0 = _extent2[0],
        d1 = _extent2[1];

    return [d0 === 0 ? 1e-5 : d0, d1];
  }

  return (0, _d3Array.extent)(values);
}

function calculateDomain(data, name, scaleType) {
  if (data.tilestats) {
    var attributes = data.tilestats.layers[0].attributes;
    var attribute = attributes.find(function (a) {
      return a.attribute === name;
    });
    return domainFromAttribute(attribute, scaleType);
  } else if (data.features) {
    var values = data.features.map(function (_ref) {
      var properties = _ref.properties;
      return properties[name];
    });
    return domainFromValues(values, scaleType);
  } else if (Array.isArray(data) && data[0][name] !== undefined) {
    var _values = data.map(function (properties) {
      return properties[name];
    });

    return domainFromValues(_values, scaleType);
  }

  return [0, 1];
}

function normalizeAccessor(accessor, data) {
  if (data.features || data.tilestats) {
    return function (_ref2) {
      var properties = _ref2.properties;
      return accessor(properties);
    };
  }

  return accessor;
}

function getColorAccessor(_ref3, scaleType, _ref4, opacity, data) {
  var name = _ref3.name;
  var colors = _ref4.colors;
  var scale = SCALE_FUNCS[scaleType]();
  scale.domain(calculateDomain(data, name, scaleType));
  scale.range(colors);
  var alpha = opacity !== undefined ? Math.round(255 * Math.pow(opacity, 1 / 2.2)) : 255;

  var accessor = function accessor(properties) {
    var rgba = (0, _d3Color.rgb)(scale(properties[name]));
    return [rgba.r, rgba.g, rgba.b, alpha];
  };

  return normalizeAccessor(accessor, data);
}

function getSizeAccessor(_ref5, scaleType, range, data) {
  var name = _ref5.name;
  var scale = SCALE_FUNCS[scaleType]();
  scale.domain(calculateDomain(data, name, scaleType));
  scale.range(range);

  var accessor = function accessor(properties) {
    return scale(properties[name]);
  };

  return normalizeAccessor(accessor, data);
}

var FORMATS = {
  date: function date(s) {
    return _momentTimezone.default.utc(s).format('MM/DD/YY HH:mm:ssa');
  },
  integer: (0, _d3Format.format)('i'),
  float: (0, _d3Format.format)('.5f'),
  timestamp: function timestamp(s) {
    return _momentTimezone.default.utc(s).format('X');
  },
  default: String
};

function getTextAccessor(_ref6, data) {
  var name = _ref6.name,
      type = _ref6.type;
  var format = FORMATS[type] || FORMATS.default;

  var accessor = function accessor(properties) {
    return format(properties[name]);
  };

  return normalizeAccessor(accessor, data);
}

function getTextPixelOffsetAccessor(_ref7, radius) {
  var alignment = _ref7.alignment,
      anchor = _ref7.anchor,
      size = _ref7.size;
  var padding = 20;
  var signX = anchor === 'middle' ? 0 : anchor === 'start' ? 1 : -1;
  var signY = alignment === 'center' ? 0 : alignment === 'bottom' ? 1 : -1;
  var sizeOffset = alignment === 'center' ? 0 : size;

  var calculateOffset = function calculateOffset(r) {
    r = RADIUS_DOWNSCALE * r;
    return [signX * (r + padding), signY * (r + padding + sizeOffset)];
  };

  return typeof radius === 'function' ? function (d) {
    return calculateOffset(radius(d));
  } : calculateOffset(radius);
}
//# sourceMappingURL=layer-map.js.map