{"version":3,"sources":["../../../src/api/maps-v3-client.ts"],"names":["MAX_GET_LENGTH","DEFAULT_CLIENT","request","method","url","accessToken","body","headers","Accept","Authorization","fetch","Error","requestJson","response","json","ok","dealWithError","error","requestData","format","FORMATS","NDJSON","data","rows","status","getParameters","type","source","geoColumn","columns","schema","clientId","parameters","push","sourceName","MAP_TYPES","QUERY","TABLE","join","mapInstantiation","connection","credentials","baseUrl","mapsUrl","length","JSON","stringify","q","client","getUrlFromMetadata","metadata","m","checkFetchLayerDataParameters","apiVersion","API_VERSIONS","V3","apiBaseUrl","fetchLayerData","formatTiles","_fetchDataUrl","mapFormat","result","defaultCredentials","localCreds","prioritizedFormats","GEOJSON","TILEJSON","f","log","assert","Object","values","TILE_FORMATS","includes","getData","deprecated","layerData","_fetchMapDataset","dataset","connectionName","cache","parseInt","URL","searchParams","get","fillInMapDatasets","datasets","token","promises","map","Promise","all","fetchMap","cartoMapId","autoRefresh","onNewData","intervalId","setInterval","changed","some","v","stopAutoRefresh","clearInterval"],"mappings":"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","sourcesContent":["/**\n * Maps API Client for Carto 3\n */\nimport {getDefaultCredentials, buildMapsUrlFromBase, CloudNativeCredentials} from '../config';\nimport {\n  API_VERSIONS,\n  encodeParameter,\n  Format,\n  FORMATS,\n  MapInstantiation,\n  MapType,\n  MAP_TYPES,\n  SchemaField,\n  TileFormat,\n  TILE_FORMATS\n} from './maps-api-common';\nimport {parseMap} from './parseMap';\nimport {log} from '@deck.gl/core';\nimport {assert} from '../utils';\n\nconst MAX_GET_LENGTH = 2048;\nconst DEFAULT_CLIENT = 'deck-gl-carto';\n\ninterface RequestParams {\n  method?: string;\n  url: string;\n  accessToken?: string;\n  body?: any;\n}\n\n/**\n * Request against Maps API\n */\nasync function request({method, url, accessToken, body}: RequestParams): Promise<Response> {\n  const headers: Record<string, string> = {\n    Accept: 'application/json'\n  };\n\n  if (accessToken) {\n    headers.Authorization = `Bearer ${accessToken}`;\n  }\n\n  if (method === 'POST') {\n    headers['Content-Type'] = 'application/json';\n  }\n\n  try {\n    /* global fetch */\n    return await fetch(url, {\n      method,\n      headers,\n      body\n    });\n  } catch (error) {\n    throw new Error(`Failed to connect to Maps API: ${error}`);\n  }\n}\n\nasync function requestJson<T = unknown>({\n  method,\n  url,\n  accessToken,\n  body\n}: RequestParams): Promise<T> {\n  const response = await request({method, url, accessToken, body});\n  const json = await response.json();\n\n  if (!response.ok) {\n    dealWithError({response, error: json.error});\n  }\n  return json as T;\n}\n\nasync function requestData({\n  method,\n  url,\n  accessToken,\n  format,\n  body\n}: RequestParams & {\n  format: Format;\n}): Promise<Response | unknown> {\n  if (format === FORMATS.NDJSON) {\n    return request({method, url, accessToken, body});\n  }\n\n  const data = await requestJson<any>({method, url, accessToken, body});\n  return data.rows ? data.rows : data;\n}\n\n/**\n * Display proper message from Maps API error\n */\nfunction dealWithError({response, error}: {response: Response; error?: string}): never {\n  switch (response.status) {\n    case 400:\n      throw new Error(`Bad request. ${error}`);\n    case 401:\n    case 403:\n      throw new Error(`Unauthorized access. ${error}`);\n    default:\n      throw new Error(error);\n  }\n}\n\ntype FetchLayerDataParams = {\n  type: MapType;\n  source: string;\n  connection: string;\n  credentials: CloudNativeCredentials;\n  geoColumn?: string;\n  columns?: string[];\n  schema?: boolean;\n  clientId?: string;\n  format?: Format;\n  formatTiles?: TileFormat;\n};\n\n/**\n * Build a URL with all required parameters\n */\nfunction getParameters({\n  type,\n  source,\n  geoColumn,\n  columns,\n  schema,\n  clientId\n}: Omit<FetchLayerDataParams, 'connection' | 'credentials'>) {\n  const parameters = [encodeParameter('client', clientId || DEFAULT_CLIENT)];\n  if (schema) {\n    parameters.push(encodeParameter('schema', true));\n  }\n\n  const sourceName = type === MAP_TYPES.QUERY ? 'q' : 'name';\n  parameters.push(encodeParameter(sourceName, source));\n\n  if (type === MAP_TYPES.TABLE) {\n    if (geoColumn) {\n      parameters.push(encodeParameter('geo_column', geoColumn));\n    }\n    if (columns) {\n      parameters.push(encodeParameter('columns', columns.join(',')));\n    }\n  }\n\n  return parameters.join('&');\n}\n\nexport async function mapInstantiation({\n  type,\n  source,\n  connection,\n  credentials,\n  geoColumn,\n  columns,\n  schema,\n  clientId\n}: FetchLayerDataParams): Promise<MapInstantiation> {\n  const baseUrl = `${credentials.mapsUrl}/${connection}/${type}`;\n  const url = `${baseUrl}?${getParameters({type, source, geoColumn, columns, schema, clientId})}`;\n  const {accessToken} = credentials;\n\n  if (url.length > MAX_GET_LENGTH && type === MAP_TYPES.QUERY) {\n    // need to be a POST request\n    const body = JSON.stringify({\n      q: source,\n      client: clientId || DEFAULT_CLIENT\n    });\n    return await requestJson({method: 'POST', url: baseUrl, accessToken, body});\n  }\n\n  return await requestJson({url, accessToken});\n}\n\nfunction getUrlFromMetadata(metadata: MapInstantiation, format: Format): string | null {\n  const m = metadata[format];\n\n  if (m && !m.error && m.url) {\n    return m.url[0];\n  }\n\n  return null;\n}\n\nfunction checkFetchLayerDataParameters({\n  type,\n  source,\n  connection,\n  credentials\n}: FetchLayerDataParams) {\n  assert(connection, 'Must define connection');\n  assert(type, 'Must define a type');\n  assert(source, 'Must define a source');\n\n  assert(credentials.apiVersion === API_VERSIONS.V3, 'Method only available for v3');\n  assert(credentials.apiBaseUrl, 'Must define apiBaseUrl');\n  assert(credentials.accessToken, 'Must define an accessToken');\n}\n\nexport interface FetchLayerDataResult {\n  data: any;\n  format: Format;\n  schema?: SchemaField[];\n}\nexport async function fetchLayerData({\n  type,\n  source,\n  connection,\n  credentials,\n  geoColumn,\n  columns,\n  format,\n  formatTiles,\n  schema,\n  clientId\n}: FetchLayerDataParams): Promise<FetchLayerDataResult> {\n  // Internally we split data fetching into two parts to allow us to\n  // conditionally fetch the actual data, depending on the metadata state\n  const {url, accessToken, mapFormat, metadata} = await _fetchDataUrl({\n    type,\n    source,\n    connection,\n    credentials,\n    geoColumn,\n    columns,\n    format,\n    formatTiles,\n    schema,\n    clientId\n  });\n\n  const data = await requestData({url, format: mapFormat, accessToken});\n  const result: FetchLayerDataResult = {data, format: mapFormat};\n  if (schema) {\n    result.schema = metadata.schema;\n  }\n\n  return result;\n}\n\nasync function _fetchDataUrl({\n  type,\n  source,\n  connection,\n  credentials,\n  geoColumn,\n  columns,\n  format,\n  formatTiles,\n  schema,\n  clientId\n}: FetchLayerDataParams) {\n  const defaultCredentials = getDefaultCredentials();\n  // Only pick up default credentials if they have been defined for\n  // correct API version\n  const localCreds = {\n    ...(defaultCredentials.apiVersion === API_VERSIONS.V3 && defaultCredentials),\n    ...credentials\n  };\n  checkFetchLayerDataParameters({type, source, connection, credentials: localCreds});\n\n  if (!localCreds.mapsUrl) {\n    localCreds.mapsUrl = buildMapsUrlFromBase(localCreds.apiBaseUrl);\n  }\n\n  const metadata = await mapInstantiation({\n    type,\n    source,\n    connection,\n    credentials: localCreds,\n    geoColumn,\n    columns,\n    schema,\n    clientId\n  });\n  let url: string | null = null;\n  let mapFormat: Format | undefined;\n\n  if (format) {\n    mapFormat = format;\n    url = getUrlFromMetadata(metadata, format);\n    assert(url, `Format ${format} not available`);\n  } else {\n    // guess map format\n    const prioritizedFormats = [FORMATS.GEOJSON, FORMATS.JSON, FORMATS.NDJSON, FORMATS.TILEJSON];\n    for (const f of prioritizedFormats) {\n      url = getUrlFromMetadata(metadata, f);\n      if (url) {\n        mapFormat = f;\n        break;\n      }\n    }\n    assert(url && mapFormat, 'Unsupported data formats received from backend.');\n  }\n\n  if (format === FORMATS.TILEJSON && formatTiles) {\n    log.assert(\n      Object.values(TILE_FORMATS).includes(formatTiles),\n      `Invalid value for formatTiles: ${formatTiles}. Use value from TILE_FORMATS`\n    );\n    url += `&${encodeParameter('formatTiles', formatTiles)}`;\n  }\n\n  const {accessToken} = localCreds;\n  return {url, accessToken, mapFormat, metadata};\n}\n\nexport async function getData({\n  type,\n  source,\n  connection,\n  credentials,\n  geoColumn,\n  columns,\n  format,\n  clientId\n}: FetchLayerDataParams) {\n  log.deprecated('getData', 'fetchLayerData')();\n  const layerData = await fetchLayerData({\n    type,\n    source,\n    connection,\n    credentials,\n    geoColumn,\n    columns,\n    format,\n    schema: false,\n    clientId\n  });\n  return layerData.data;\n}\n\n/* global clearInterval, setInterval, URL */\nasync function _fetchMapDataset(\n  dataset,\n  accessToken: string,\n  credentials: CloudNativeCredentials,\n  clientId?: string\n) {\n  const {connectionName: connection, columns, geoColumn, source, type} = dataset;\n  // First fetch metadata\n  const {url, mapFormat} = await _fetchDataUrl({\n    credentials: {...credentials, accessToken},\n    connection,\n    columns,\n    geoColumn,\n    source,\n    type,\n    clientId\n  });\n\n  // Extract the last time the data changed\n  const cache = parseInt(new URL(url).searchParams.get('cache') || '', 10);\n  if (cache && dataset.cache === cache) {\n    return false;\n  }\n  dataset.cache = cache;\n\n  // Only fetch if the data has changed\n  dataset.data = await requestData({url, format: mapFormat, accessToken});\n\n  return true;\n}\n\nasync function fillInMapDatasets(\n  {datasets, token},\n  clientId: string,\n  credentials: CloudNativeCredentials\n) {\n  const promises = datasets.map(dataset => _fetchMapDataset(dataset, token, credentials, clientId));\n  return await Promise.all(promises);\n}\n\nexport async function fetchMap({\n  cartoMapId,\n  clientId,\n  credentials,\n  autoRefresh,\n  onNewData\n}: {\n  cartoMapId: string;\n  clientId: string;\n  credentials?: CloudNativeCredentials;\n  autoRefresh?: number;\n  onNewData?: (map: any) => void;\n}) {\n  const defaultCredentials = getDefaultCredentials();\n  const localCreds = {\n    ...(defaultCredentials.apiVersion === API_VERSIONS.V3 && defaultCredentials),\n    ...credentials\n  } as CloudNativeCredentials;\n  const {accessToken} = localCreds;\n\n  assert(cartoMapId, 'Must define CARTO map id: fetchMap({cartoMapId: \"XXXX-XXXX-XXXX\"})');\n\n  assert(localCreds.apiVersion === API_VERSIONS.V3, 'Method only available for v3');\n  assert(localCreds.apiBaseUrl, 'Must define apiBaseUrl');\n  if (!localCreds.mapsUrl) {\n    localCreds.mapsUrl = buildMapsUrlFromBase(localCreds.apiBaseUrl);\n  }\n\n  if (autoRefresh || onNewData) {\n    assert(onNewData, 'Must define `onNewData` when using autoRefresh');\n    assert(typeof onNewData === 'function', '`onNewData` must be a function');\n    assert(\n      typeof autoRefresh === 'number' && autoRefresh > 0,\n      '`autoRefresh` must be a positive number'\n    );\n  }\n\n  const url = `${localCreds.mapsUrl}/public/${cartoMapId}`;\n  const map = await requestJson<any>({url, accessToken});\n\n  // Periodically check if the data has changed. Note that this\n  // will not update when a map is published.\n  let stopAutoRefresh: (() => void) | undefined;\n  if (autoRefresh) {\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    const intervalId = setInterval(async () => {\n      const changed = await fillInMapDatasets(map, clientId, localCreds);\n      if (onNewData && changed.some(v => v === true)) {\n        onNewData(parseMap(map));\n      }\n    }, autoRefresh * 1000);\n    stopAutoRefresh = () => {\n      clearInterval(intervalId);\n    };\n  }\n\n  // Mutates map.datasets so that dataset.data contains data\n  await fillInMapDatasets(map, clientId, localCreds);\n  return {\n    ...parseMap(map),\n    ...{stopAutoRefresh}\n  };\n}\n"],"file":"maps-v3-client.js"}