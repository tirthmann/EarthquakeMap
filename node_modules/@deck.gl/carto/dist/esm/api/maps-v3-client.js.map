{"version":3,"sources":["../../../src/api/maps-v3-client.ts"],"names":["getDefaultCredentials","buildMapsUrlFromBase","API_VERSIONS","encodeParameter","FORMATS","MAP_TYPES","TILE_FORMATS","parseMap","log","assert","MAX_GET_LENGTH","DEFAULT_CLIENT","request","method","url","accessToken","body","headers","Accept","Authorization","fetch","error","Error","requestJson","response","json","ok","dealWithError","requestData","format","NDJSON","data","rows","status","getParameters","type","source","geoColumn","columns","schema","clientId","parameters","push","sourceName","QUERY","TABLE","join","mapInstantiation","connection","credentials","baseUrl","mapsUrl","length","JSON","stringify","q","client","getUrlFromMetadata","metadata","m","checkFetchLayerDataParameters","apiVersion","V3","apiBaseUrl","fetchLayerData","formatTiles","mapFormat","_fetchDataUrl","result","defaultCredentials","localCreds","prioritizedFormats","GEOJSON","TILEJSON","f","Object","values","includes","getData","deprecated","layerData","_fetchMapDataset","dataset","connectionName","cache","parseInt","URL","searchParams","get","fillInMapDatasets","datasets","token","promises","map","Promise","all","fetchMap","cartoMapId","autoRefresh","onNewData","stopAutoRefresh","intervalId","setInterval","changed","some","v","clearInterval"],"mappings":"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","sourcesContent":["/**\n * Maps API Client for Carto 3\n */\nimport {getDefaultCredentials, buildMapsUrlFromBase, CloudNativeCredentials} from '../config';\nimport {\n  API_VERSIONS,\n  encodeParameter,\n  Format,\n  FORMATS,\n  MapInstantiation,\n  MapType,\n  MAP_TYPES,\n  SchemaField,\n  TileFormat,\n  TILE_FORMATS\n} from './maps-api-common';\nimport {parseMap} from './parseMap';\nimport {log} from '@deck.gl/core';\nimport {assert} from '../utils';\n\nconst MAX_GET_LENGTH = 2048;\nconst DEFAULT_CLIENT = 'deck-gl-carto';\n\ninterface RequestParams {\n  method?: string;\n  url: string;\n  accessToken?: string;\n  body?: any;\n}\n\n/**\n * Request against Maps API\n */\nasync function request({method, url, accessToken, body}: RequestParams): Promise<Response> {\n  const headers: Record<string, string> = {\n    Accept: 'application/json'\n  };\n\n  if (accessToken) {\n    headers.Authorization = `Bearer ${accessToken}`;\n  }\n\n  if (method === 'POST') {\n    headers['Content-Type'] = 'application/json';\n  }\n\n  try {\n    /* global fetch */\n    return await fetch(url, {\n      method,\n      headers,\n      body\n    });\n  } catch (error) {\n    throw new Error(`Failed to connect to Maps API: ${error}`);\n  }\n}\n\nasync function requestJson<T = unknown>({\n  method,\n  url,\n  accessToken,\n  body\n}: RequestParams): Promise<T> {\n  const response = await request({method, url, accessToken, body});\n  const json = await response.json();\n\n  if (!response.ok) {\n    dealWithError({response, error: json.error});\n  }\n  return json as T;\n}\n\nasync function requestData({\n  method,\n  url,\n  accessToken,\n  format,\n  body\n}: RequestParams & {\n  format: Format;\n}): Promise<Response | unknown> {\n  if (format === FORMATS.NDJSON) {\n    return request({method, url, accessToken, body});\n  }\n\n  const data = await requestJson<any>({method, url, accessToken, body});\n  return data.rows ? data.rows : data;\n}\n\n/**\n * Display proper message from Maps API error\n */\nfunction dealWithError({response, error}: {response: Response; error?: string}): never {\n  switch (response.status) {\n    case 400:\n      throw new Error(`Bad request. ${error}`);\n    case 401:\n    case 403:\n      throw new Error(`Unauthorized access. ${error}`);\n    default:\n      throw new Error(error);\n  }\n}\n\ntype FetchLayerDataParams = {\n  type: MapType;\n  source: string;\n  connection: string;\n  credentials: CloudNativeCredentials;\n  geoColumn?: string;\n  columns?: string[];\n  schema?: boolean;\n  clientId?: string;\n  format?: Format;\n  formatTiles?: TileFormat;\n};\n\n/**\n * Build a URL with all required parameters\n */\nfunction getParameters({\n  type,\n  source,\n  geoColumn,\n  columns,\n  schema,\n  clientId\n}: Omit<FetchLayerDataParams, 'connection' | 'credentials'>) {\n  const parameters = [encodeParameter('client', clientId || DEFAULT_CLIENT)];\n  if (schema) {\n    parameters.push(encodeParameter('schema', true));\n  }\n\n  const sourceName = type === MAP_TYPES.QUERY ? 'q' : 'name';\n  parameters.push(encodeParameter(sourceName, source));\n\n  if (type === MAP_TYPES.TABLE) {\n    if (geoColumn) {\n      parameters.push(encodeParameter('geo_column', geoColumn));\n    }\n    if (columns) {\n      parameters.push(encodeParameter('columns', columns.join(',')));\n    }\n  }\n\n  return parameters.join('&');\n}\n\nexport async function mapInstantiation({\n  type,\n  source,\n  connection,\n  credentials,\n  geoColumn,\n  columns,\n  schema,\n  clientId\n}: FetchLayerDataParams): Promise<MapInstantiation> {\n  const baseUrl = `${credentials.mapsUrl}/${connection}/${type}`;\n  const url = `${baseUrl}?${getParameters({type, source, geoColumn, columns, schema, clientId})}`;\n  const {accessToken} = credentials;\n\n  if (url.length > MAX_GET_LENGTH && type === MAP_TYPES.QUERY) {\n    // need to be a POST request\n    const body = JSON.stringify({\n      q: source,\n      client: clientId || DEFAULT_CLIENT\n    });\n    return await requestJson({method: 'POST', url: baseUrl, accessToken, body});\n  }\n\n  return await requestJson({url, accessToken});\n}\n\nfunction getUrlFromMetadata(metadata: MapInstantiation, format: Format): string | null {\n  const m = metadata[format];\n\n  if (m && !m.error && m.url) {\n    return m.url[0];\n  }\n\n  return null;\n}\n\nfunction checkFetchLayerDataParameters({\n  type,\n  source,\n  connection,\n  credentials\n}: FetchLayerDataParams) {\n  assert(connection, 'Must define connection');\n  assert(type, 'Must define a type');\n  assert(source, 'Must define a source');\n\n  assert(credentials.apiVersion === API_VERSIONS.V3, 'Method only available for v3');\n  assert(credentials.apiBaseUrl, 'Must define apiBaseUrl');\n  assert(credentials.accessToken, 'Must define an accessToken');\n}\n\nexport interface FetchLayerDataResult {\n  data: any;\n  format: Format;\n  schema?: SchemaField[];\n}\nexport async function fetchLayerData({\n  type,\n  source,\n  connection,\n  credentials,\n  geoColumn,\n  columns,\n  format,\n  formatTiles,\n  schema,\n  clientId\n}: FetchLayerDataParams): Promise<FetchLayerDataResult> {\n  // Internally we split data fetching into two parts to allow us to\n  // conditionally fetch the actual data, depending on the metadata state\n  const {url, accessToken, mapFormat, metadata} = await _fetchDataUrl({\n    type,\n    source,\n    connection,\n    credentials,\n    geoColumn,\n    columns,\n    format,\n    formatTiles,\n    schema,\n    clientId\n  });\n\n  const data = await requestData({url, format: mapFormat, accessToken});\n  const result: FetchLayerDataResult = {data, format: mapFormat};\n  if (schema) {\n    result.schema = metadata.schema;\n  }\n\n  return result;\n}\n\nasync function _fetchDataUrl({\n  type,\n  source,\n  connection,\n  credentials,\n  geoColumn,\n  columns,\n  format,\n  formatTiles,\n  schema,\n  clientId\n}: FetchLayerDataParams) {\n  const defaultCredentials = getDefaultCredentials();\n  // Only pick up default credentials if they have been defined for\n  // correct API version\n  const localCreds = {\n    ...(defaultCredentials.apiVersion === API_VERSIONS.V3 && defaultCredentials),\n    ...credentials\n  };\n  checkFetchLayerDataParameters({type, source, connection, credentials: localCreds});\n\n  if (!localCreds.mapsUrl) {\n    localCreds.mapsUrl = buildMapsUrlFromBase(localCreds.apiBaseUrl);\n  }\n\n  const metadata = await mapInstantiation({\n    type,\n    source,\n    connection,\n    credentials: localCreds,\n    geoColumn,\n    columns,\n    schema,\n    clientId\n  });\n  let url: string | null = null;\n  let mapFormat: Format | undefined;\n\n  if (format) {\n    mapFormat = format;\n    url = getUrlFromMetadata(metadata, format);\n    assert(url, `Format ${format} not available`);\n  } else {\n    // guess map format\n    const prioritizedFormats = [FORMATS.GEOJSON, FORMATS.JSON, FORMATS.NDJSON, FORMATS.TILEJSON];\n    for (const f of prioritizedFormats) {\n      url = getUrlFromMetadata(metadata, f);\n      if (url) {\n        mapFormat = f;\n        break;\n      }\n    }\n    assert(url && mapFormat, 'Unsupported data formats received from backend.');\n  }\n\n  if (format === FORMATS.TILEJSON && formatTiles) {\n    log.assert(\n      Object.values(TILE_FORMATS).includes(formatTiles),\n      `Invalid value for formatTiles: ${formatTiles}. Use value from TILE_FORMATS`\n    );\n    url += `&${encodeParameter('formatTiles', formatTiles)}`;\n  }\n\n  const {accessToken} = localCreds;\n  return {url, accessToken, mapFormat, metadata};\n}\n\nexport async function getData({\n  type,\n  source,\n  connection,\n  credentials,\n  geoColumn,\n  columns,\n  format,\n  clientId\n}: FetchLayerDataParams) {\n  log.deprecated('getData', 'fetchLayerData')();\n  const layerData = await fetchLayerData({\n    type,\n    source,\n    connection,\n    credentials,\n    geoColumn,\n    columns,\n    format,\n    schema: false,\n    clientId\n  });\n  return layerData.data;\n}\n\n/* global clearInterval, setInterval, URL */\nasync function _fetchMapDataset(\n  dataset,\n  accessToken: string,\n  credentials: CloudNativeCredentials,\n  clientId?: string\n) {\n  const {connectionName: connection, columns, geoColumn, source, type} = dataset;\n  // First fetch metadata\n  const {url, mapFormat} = await _fetchDataUrl({\n    credentials: {...credentials, accessToken},\n    connection,\n    columns,\n    geoColumn,\n    source,\n    type,\n    clientId\n  });\n\n  // Extract the last time the data changed\n  const cache = parseInt(new URL(url).searchParams.get('cache') || '', 10);\n  if (cache && dataset.cache === cache) {\n    return false;\n  }\n  dataset.cache = cache;\n\n  // Only fetch if the data has changed\n  dataset.data = await requestData({url, format: mapFormat, accessToken});\n\n  return true;\n}\n\nasync function fillInMapDatasets(\n  {datasets, token},\n  clientId: string,\n  credentials: CloudNativeCredentials\n) {\n  const promises = datasets.map(dataset => _fetchMapDataset(dataset, token, credentials, clientId));\n  return await Promise.all(promises);\n}\n\nexport async function fetchMap({\n  cartoMapId,\n  clientId,\n  credentials,\n  autoRefresh,\n  onNewData\n}: {\n  cartoMapId: string;\n  clientId: string;\n  credentials?: CloudNativeCredentials;\n  autoRefresh?: number;\n  onNewData?: (map: any) => void;\n}) {\n  const defaultCredentials = getDefaultCredentials();\n  const localCreds = {\n    ...(defaultCredentials.apiVersion === API_VERSIONS.V3 && defaultCredentials),\n    ...credentials\n  } as CloudNativeCredentials;\n  const {accessToken} = localCreds;\n\n  assert(cartoMapId, 'Must define CARTO map id: fetchMap({cartoMapId: \"XXXX-XXXX-XXXX\"})');\n\n  assert(localCreds.apiVersion === API_VERSIONS.V3, 'Method only available for v3');\n  assert(localCreds.apiBaseUrl, 'Must define apiBaseUrl');\n  if (!localCreds.mapsUrl) {\n    localCreds.mapsUrl = buildMapsUrlFromBase(localCreds.apiBaseUrl);\n  }\n\n  if (autoRefresh || onNewData) {\n    assert(onNewData, 'Must define `onNewData` when using autoRefresh');\n    assert(typeof onNewData === 'function', '`onNewData` must be a function');\n    assert(\n      typeof autoRefresh === 'number' && autoRefresh > 0,\n      '`autoRefresh` must be a positive number'\n    );\n  }\n\n  const url = `${localCreds.mapsUrl}/public/${cartoMapId}`;\n  const map = await requestJson<any>({url, accessToken});\n\n  // Periodically check if the data has changed. Note that this\n  // will not update when a map is published.\n  let stopAutoRefresh: (() => void) | undefined;\n  if (autoRefresh) {\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    const intervalId = setInterval(async () => {\n      const changed = await fillInMapDatasets(map, clientId, localCreds);\n      if (onNewData && changed.some(v => v === true)) {\n        onNewData(parseMap(map));\n      }\n    }, autoRefresh * 1000);\n    stopAutoRefresh = () => {\n      clearInterval(intervalId);\n    };\n  }\n\n  // Mutates map.datasets so that dataset.data contains data\n  await fillInMapDatasets(map, clientId, localCreds);\n  return {\n    ...parseMap(map),\n    ...{stopAutoRefresh}\n  };\n}\n"],"file":"maps-v3-client.js"}