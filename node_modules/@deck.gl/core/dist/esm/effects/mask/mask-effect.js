import { Texture2D } from '@luma.gl/core';
import { equals } from '@math.gl/core';
import MaskPass from '../../passes/mask-pass';
import Effect from '../../lib/effect';
import { OPERATION } from '../../lib/constants';
import { getMaskBounds, getMaskViewport } from './utils';
import log from '../../utils/log';
export default class MaskEffect extends Effect {
  constructor(props) {
    super(props);
    this.dummyMaskMap = null;
    this.useInPicking = true;
    this.channels = [];
    this.masks = null;
  }

  preRender(gl, {
    layers,
    layerFilter,
    viewports,
    onViewportActive,
    views
  }) {
    if (!this.dummyMaskMap) {
      this.dummyMaskMap = new Texture2D(gl, {
        width: 1,
        height: 1
      });
    }

    const maskLayers = layers.filter(l => l.props.operation === OPERATION.MASK && l.props.visible);

    if (maskLayers.length === 0) {
      this.masks = null;
      this.channels.length = 0;
      return;
    }

    this.masks = {};

    if (!this.maskPass) {
      this.maskPass = new MaskPass(gl, {
        id: 'default-mask'
      });
      this.maskMap = this.maskPass.maskMap;
    }

    const channelMap = this._sortMaskChannels(maskLayers);

    const viewport = viewports[0];
    const viewportChanged = !this.lastViewport || !this.lastViewport.equals(viewport);

    for (const maskId in channelMap) {
      this._renderChannel(channelMap[maskId], {
        layerFilter,
        onViewportActive,
        views,
        viewport,
        viewportChanged
      });
    }
  }

  _renderChannel(channelInfo, {
    layerFilter,
    onViewportActive,
    views,
    viewport,
    viewportChanged
  }) {
    const oldChannelInfo = this.channels[channelInfo.index];
    const maskChanged = channelInfo === oldChannelInfo || oldChannelInfo.layers.length !== channelInfo.layers.length || channelInfo.layerBounds.some((b, i) => b !== oldChannelInfo.layerBounds[i]);
    channelInfo.bounds = oldChannelInfo.bounds;
    channelInfo.maskBounds = oldChannelInfo.maskBounds;
    this.channels[channelInfo.index] = channelInfo;

    if (maskChanged || viewportChanged) {
      this.lastViewport = viewport;
      channelInfo.bounds = getMaskBounds({
        layers: channelInfo.layers,
        viewport
      });

      if (maskChanged || !equals(channelInfo.bounds, oldChannelInfo.bounds)) {
        const {
          maskPass,
          maskMap
        } = this;
        const maskViewport = getMaskViewport({
          bounds: channelInfo.bounds,
          viewport,
          width: maskMap.width,
          height: maskMap.height
        });
        channelInfo.maskBounds = maskViewport ? maskViewport.getBounds() : [0, 0, 1, 1];
        maskPass.render({
          channel: channelInfo.index,
          layers: channelInfo.layers,
          layerFilter,
          viewports: maskViewport ? [maskViewport] : [],
          onViewportActive,
          views,
          moduleParameters: {
            devicePixelRatio: 1
          }
        });
      }
    }

    this.masks[channelInfo.id] = {
      index: channelInfo.index,
      bounds: channelInfo.maskBounds,
      coordinateOrigin: channelInfo.coordinateOrigin,
      coordinateSystem: channelInfo.coordinateSystem
    };
  }

  _sortMaskChannels(maskLayers) {
    const channelMap = {};
    let channelCount = 0;

    for (const layer of maskLayers) {
      const {
        id
      } = layer.root;
      let channelInfo = channelMap[id];

      if (!channelInfo) {
        if (++channelCount > 4) {
          log.warn('Too many mask layers. The max supported is 4')();
          continue;
        }

        channelInfo = {
          id,
          index: this.channels.findIndex(c => (c === null || c === void 0 ? void 0 : c.id) === id),
          layers: [],
          layerBounds: [],
          coordinateOrigin: layer.root.props.coordinateOrigin,
          coordinateSystem: layer.root.props.coordinateSystem
        };
        channelMap[id] = channelInfo;
      }

      channelInfo.layers.push(layer);
      channelInfo.layerBounds.push(layer.getBounds());
    }

    for (let i = 0; i < 4; i++) {
      const channelInfo = this.channels[i];

      if (!channelInfo || !(channelInfo.id in channelMap)) {
        this.channels[i] = null;
      }
    }

    for (const maskId in channelMap) {
      const channelInfo = channelMap[maskId];

      if (channelInfo.index < 0) {
        channelInfo.index = this.channels.findIndex(c => !c);
        this.channels[channelInfo.index] = channelInfo;
      }
    }

    return channelMap;
  }

  getModuleParameters() {
    return {
      maskMap: this.masks ? this.maskMap : this.dummyMaskMap,
      maskChannels: this.masks
    };
  }

  cleanup() {
    if (this.dummyMaskMap) {
      this.dummyMaskMap.delete();
      this.dummyMaskMap = null;
    }

    if (this.maskPass) {
      this.maskPass.delete();
      this.maskPass = null;
      this.maskMap = null;
    }

    this.lastViewport = null;
    this.masks = null;
    this.channels.length = 0;
  }

}
//# sourceMappingURL=mask-effect.js.map