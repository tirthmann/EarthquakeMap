{"version":3,"sources":["../../../../src/effects/mask/mask-effect.js"],"names":["Texture2D","equals","MaskPass","Effect","OPERATION","getMaskBounds","getMaskViewport","log","MaskEffect","constructor","props","dummyMaskMap","useInPicking","channels","masks","preRender","gl","layers","layerFilter","viewports","onViewportActive","views","width","height","maskLayers","filter","l","operation","MASK","visible","length","maskPass","id","maskMap","channelMap","_sortMaskChannels","viewport","viewportChanged","lastViewport","maskId","_renderChannel","channelInfo","oldChannelInfo","index","maskChanged","layerBounds","some","b","i","bounds","maskBounds","maskViewport","getBounds","render","channel","moduleParameters","devicePixelRatio","coordinateOrigin","coordinateSystem","channelCount","layer","root","warn","findIndex","c","push","getModuleParameters","maskChannels","cleanup","delete"],"mappings":"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","sourcesContent":["import {Texture2D} from '@luma.gl/core';\n// import {readPixelsToArray} from '@luma.gl/core';\nimport {equals} from '@math.gl/core';\nimport MaskPass from '../../passes/mask-pass';\nimport Effect from '../../lib/effect';\nimport {OPERATION} from '../../lib/constants';\nimport {getMaskBounds, getMaskViewport} from './utils';\nimport log from '../../utils/log';\n\n// Class to manage mask effect\nexport default class MaskEffect extends Effect {\n  constructor(props) {\n    super(props);\n    this.dummyMaskMap = null;\n    this.useInPicking = true;\n    this.channels = [];\n    this.masks = null;\n  }\n\n  preRender(gl, {layers, layerFilter, viewports, onViewportActive, views}) {\n    if (!this.dummyMaskMap) {\n      this.dummyMaskMap = new Texture2D(gl, {\n        width: 1,\n        height: 1\n      });\n    }\n\n    const maskLayers = layers.filter(l => l.props.operation === OPERATION.MASK && l.props.visible);\n    if (maskLayers.length === 0) {\n      this.masks = null;\n      this.channels.length = 0;\n      return;\n    }\n    this.masks = {};\n\n    if (!this.maskPass) {\n      this.maskPass = new MaskPass(gl, {id: 'default-mask'});\n      this.maskMap = this.maskPass.maskMap;\n    }\n\n    // Map layers to channels\n    const channelMap = this._sortMaskChannels(maskLayers);\n    // TODO - support multiple views\n    const viewport = viewports[0];\n    const viewportChanged = !this.lastViewport || !this.lastViewport.equals(viewport);\n\n    for (const maskId in channelMap) {\n      this._renderChannel(channelMap[maskId], {\n        layerFilter,\n        onViewportActive,\n        views,\n        viewport,\n        viewportChanged\n      });\n    }\n\n    // // Debug show FBO contents on screen\n    // const color = readPixelsToArray(this.maskMap);\n    // let canvas = document.getElementById('fbo-canvas');\n    // if (!canvas) {\n    //   canvas = document.createElement('canvas');\n    //   canvas.id = 'fbo-canvas';\n    //   canvas.width = this.maskMap.width;\n    //   canvas.height = this.maskMap.height;\n    //   canvas.style.zIndex = 100;\n    //   canvas.style.position = 'absolute';\n    //   canvas.style.right = 0;\n    //   canvas.style.border = 'blue 1px solid';\n    //   canvas.style.width = '256px';\n    //   canvas.style.transform = 'scaleY(-1)';\n    //   document.body.appendChild(canvas);\n    // }\n    // const ctx = canvas.getContext('2d');\n    // const imageData = ctx.createImageData(this.maskMap.width, this.maskMap.height);\n    // for (let i = 0; i < color.length; i += 4) {\n    //   imageData.data[i + 0] = color[i + 0];\n    //   imageData.data[i + 1] = color[i + 1];\n    //   imageData.data[i + 2] = color[i + 2];\n    //   imageData.data[i + 3] = color[i + 3] + 128;\n    // }\n    // ctx.putImageData(imageData, 0, 0);\n  }\n\n  _renderChannel(channelInfo, {layerFilter, onViewportActive, views, viewport, viewportChanged}) {\n    const oldChannelInfo = this.channels[channelInfo.index];\n    const maskChanged =\n      // If a channel is new\n      channelInfo === oldChannelInfo ||\n      // If sublayers have changed\n      oldChannelInfo.layers.length !== channelInfo.layers.length ||\n      // If a sublayer's positions have been updated, the cached bounds will change shallowly\n      channelInfo.layerBounds.some((b, i) => b !== oldChannelInfo.layerBounds[i]);\n\n    channelInfo.bounds = oldChannelInfo.bounds;\n    channelInfo.maskBounds = oldChannelInfo.maskBounds;\n    this.channels[channelInfo.index] = channelInfo;\n\n    if (maskChanged || viewportChanged) {\n      // Recalculate mask bounds\n      this.lastViewport = viewport;\n\n      channelInfo.bounds = getMaskBounds({layers: channelInfo.layers, viewport});\n\n      if (maskChanged || !equals(channelInfo.bounds, oldChannelInfo.bounds)) {\n        // Rerender mask FBO\n        const {maskPass, maskMap} = this;\n\n        const maskViewport = getMaskViewport({\n          bounds: channelInfo.bounds,\n          viewport,\n          width: maskMap.width,\n          height: maskMap.height\n        });\n\n        channelInfo.maskBounds = maskViewport ? maskViewport.getBounds() : [0, 0, 1, 1];\n\n        maskPass.render({\n          channel: channelInfo.index,\n          layers: channelInfo.layers,\n          layerFilter,\n          viewports: maskViewport ? [maskViewport] : [],\n          onViewportActive,\n          views,\n          moduleParameters: {\n            devicePixelRatio: 1\n          }\n        });\n      }\n    }\n\n    this.masks[channelInfo.id] = {\n      index: channelInfo.index,\n      bounds: channelInfo.maskBounds,\n      coordinateOrigin: channelInfo.coordinateOrigin,\n      coordinateSystem: channelInfo.coordinateSystem\n    };\n  }\n\n  /**\n   * Find a channel to render each mask into\n   * If a maskId already exists, diff and update the existing channel\n   * Otherwise replace a removed mask\n   * Otherwise create a new channel\n   */\n  _sortMaskChannels(maskLayers) {\n    const channelMap = {};\n    let channelCount = 0;\n    for (const layer of maskLayers) {\n      const {id} = layer.root;\n      let channelInfo = channelMap[id];\n      if (!channelInfo) {\n        if (++channelCount > 4) {\n          log.warn('Too many mask layers. The max supported is 4')();\n          continue; // eslint-disable-line no-continue\n        }\n        channelInfo = {\n          id,\n          index: this.channels.findIndex(c => c?.id === id),\n          layers: [],\n          layerBounds: [],\n          coordinateOrigin: layer.root.props.coordinateOrigin,\n          coordinateSystem: layer.root.props.coordinateSystem\n        };\n        channelMap[id] = channelInfo;\n      }\n      channelInfo.layers.push(layer);\n      channelInfo.layerBounds.push(layer.getBounds());\n    }\n\n    for (let i = 0; i < 4; i++) {\n      const channelInfo = this.channels[i];\n      if (!channelInfo || !(channelInfo.id in channelMap)) {\n        // The mask id at this channel no longer exists\n        this.channels[i] = null;\n      }\n    }\n\n    for (const maskId in channelMap) {\n      const channelInfo = channelMap[maskId];\n\n      if (channelInfo.index < 0) {\n        channelInfo.index = this.channels.findIndex(c => !c);\n        this.channels[channelInfo.index] = channelInfo;\n      }\n    }\n    return channelMap;\n  }\n\n  getModuleParameters() {\n    return {\n      maskMap: this.masks ? this.maskMap : this.dummyMaskMap,\n      maskChannels: this.masks\n    };\n  }\n\n  cleanup() {\n    if (this.dummyMaskMap) {\n      this.dummyMaskMap.delete();\n      this.dummyMaskMap = null;\n    }\n\n    if (this.maskPass) {\n      this.maskPass.delete();\n      this.maskPass = null;\n      this.maskMap = null;\n    }\n\n    this.lastViewport = null;\n    this.masks = null;\n    this.channels.length = 0;\n  }\n}\n"],"file":"mask-effect.js"}