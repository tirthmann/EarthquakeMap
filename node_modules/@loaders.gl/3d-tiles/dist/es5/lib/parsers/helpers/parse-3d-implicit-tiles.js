"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseImplicitTiles = parseImplicitTiles;
exports.replaceContentUrlTemplate = replaceContentUrlTemplate;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _tile3dSubtreeLoader = require("../../../tile-3d-subtree-loader");

var _core = require("@loaders.gl/core");

var QUADTREE_DEVISION_COUNT = 4;
var OCTREE_DEVISION_COUNT = 8;
var SUBDIVISION_COUNT_MAP = {
  QUADTREE: QUADTREE_DEVISION_COUNT,
  OCTREE: OCTREE_DEVISION_COUNT
};

function parseImplicitTiles(_x, _x2) {
  return _parseImplicitTiles.apply(this, arguments);
}

function _parseImplicitTiles() {
  _parseImplicitTiles = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(subtree, options) {
    var parentData,
        childIndex,
        level,
        globalData,
        subdivisionScheme,
        subtreeLevels,
        maximumLevel,
        contentUrlTemplate,
        subtreesUriTemplate,
        basePath,
        tile,
        childrenPerTile,
        childX,
        childY,
        childZ,
        levelOffset,
        childTileMortonIndex,
        tileAvailabilityIndex,
        childTileX,
        childTileY,
        childTileZ,
        isChildSubtreeAvailable,
        x,
        y,
        z,
        lev,
        subtreePath,
        childSubtreeUrl,
        childSubtree,
        isTileAvailable,
        isContentAvailable,
        childTileLevel,
        pData,
        index,
        currentTile,
        globalLevel,
        childCoordinates,
        formattedTile,
        _args = arguments;
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            parentData = _args.length > 2 && _args[2] !== undefined ? _args[2] : {
              mortonIndex: 0,
              x: 0,
              y: 0,
              z: 0
            };
            childIndex = _args.length > 3 && _args[3] !== undefined ? _args[3] : 0;
            level = _args.length > 4 && _args[4] !== undefined ? _args[4] : 0;
            globalData = _args.length > 5 && _args[5] !== undefined ? _args[5] : {
              level: 0,
              mortonIndex: 0,
              x: 0,
              y: 0,
              z: 0
            };
            subdivisionScheme = options.subdivisionScheme, subtreeLevels = options.subtreeLevels, maximumLevel = options.maximumLevel, contentUrlTemplate = options.contentUrlTemplate, subtreesUriTemplate = options.subtreesUriTemplate, basePath = options.basePath;
            tile = {
              children: [],
              lodMetricValue: 0,
              contentUrl: ''
            };
            childrenPerTile = SUBDIVISION_COUNT_MAP[subdivisionScheme];
            childX = childIndex & 1;
            childY = childIndex >> 1 & 1;
            childZ = childIndex >> 2 & 1;
            levelOffset = (Math.pow(childrenPerTile, level) - 1) / (childrenPerTile - 1);
            childTileMortonIndex = concatBits(parentData.mortonIndex, childIndex);
            tileAvailabilityIndex = levelOffset + childTileMortonIndex;
            childTileX = concatBits(parentData.x, childX);
            childTileY = concatBits(parentData.y, childY);
            childTileZ = concatBits(parentData.z, childZ);
            isChildSubtreeAvailable = false;

            if (level + 1 > subtreeLevels) {
              isChildSubtreeAvailable = getAvailabilityResult(subtree.childSubtreeAvailability, childTileMortonIndex);
            }

            x = concatBits(globalData.x, childTileX);
            y = concatBits(globalData.y, childTileY);
            z = concatBits(globalData.z, childTileZ);
            lev = level + globalData.level;

            if (!isChildSubtreeAvailable) {
              _context.next = 40;
              break;
            }

            subtreePath = "".concat(basePath, "/").concat(subtreesUriTemplate);
            childSubtreeUrl = replaceContentUrlTemplate(subtreePath, lev, x, y, z);
            _context.next = 27;
            return (0, _core.load)(childSubtreeUrl, _tile3dSubtreeLoader.Tile3DSubtreeLoader);

          case 27:
            childSubtree = _context.sent;
            subtree = childSubtree;
            globalData.mortonIndex = childTileMortonIndex;
            globalData.x = childTileX;
            globalData.y = childTileY;
            globalData.z = childTileZ;
            globalData.level = level;
            childTileMortonIndex = 0;
            tileAvailabilityIndex = 0;
            childTileX = 0;
            childTileY = 0;
            childTileZ = 0;
            level = 0;

          case 40:
            isTileAvailable = getAvailabilityResult(subtree.tileAvailability, tileAvailabilityIndex);

            if (!(!isTileAvailable || level > maximumLevel)) {
              _context.next = 43;
              break;
            }

            return _context.abrupt("return", tile);

          case 43:
            isContentAvailable = getAvailabilityResult(subtree.contentAvailability, tileAvailabilityIndex);

            if (isContentAvailable) {
              tile.contentUrl = replaceContentUrlTemplate(contentUrlTemplate, lev, x, y, z);
            }

            childTileLevel = level + 1;
            pData = {
              mortonIndex: childTileMortonIndex,
              x: childTileX,
              y: childTileY,
              z: childTileZ
            };
            index = 0;

          case 48:
            if (!(index < childrenPerTile)) {
              _context.next = 56;
              break;
            }

            _context.next = 51;
            return parseImplicitTiles(subtree, options, pData, index, childTileLevel, globalData);

          case 51:
            currentTile = _context.sent;

            if (currentTile.contentUrl || currentTile.children.length) {
              globalLevel = lev + 1;
              childCoordinates = {
                childTileX: childTileX,
                childTileY: childTileY,
                childTileZ: childTileZ
              };
              formattedTile = formatTileData(currentTile, globalLevel, childCoordinates, options);
              tile.children.push(formattedTile);
            }

          case 53:
            index++;
            _context.next = 48;
            break;

          case 56:
            return _context.abrupt("return", tile);

          case 57:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _parseImplicitTiles.apply(this, arguments);
}

function getAvailabilityResult(availabilityData, index) {
  if ('constant' in availabilityData) {
    return Boolean(availabilityData.constant);
  }

  if (availabilityData.explicitBitstream) {
    return getBooleanValueFromBitstream(index, availabilityData.explicitBitstream);
  }

  return false;
}

function formatTileData(tile, level, childCoordinates, options) {
  var basePath = options.basePath,
      refine = options.refine,
      getRefine = options.getRefine,
      lodMetricType = options.lodMetricType,
      getTileType = options.getTileType,
      rootLodMetricValue = options.rootLodMetricValue,
      rootBoundingVolume = options.rootBoundingVolume;
  var uri = tile.contentUrl && tile.contentUrl.replace("".concat(basePath, "/"), '');
  var lodMetricValue = rootLodMetricValue / Math.pow(2, level);
  var boundingVolume = calculateBoundingVolumeForChildTile(level, rootBoundingVolume, childCoordinates);
  return {
    children: tile.children,
    contentUrl: tile.contentUrl,
    content: {
      uri: uri
    },
    id: tile.contentUrl,
    refine: getRefine(refine),
    type: getTileType(tile),
    lodMetricType: lodMetricType,
    lodMetricValue: lodMetricValue,
    boundingVolume: boundingVolume
  };
}

function calculateBoundingVolumeForChildTile(level, rootBoundingVolume, childCoordinates) {
  if (rootBoundingVolume.region) {
    var childTileX = childCoordinates.childTileX,
        childTileY = childCoordinates.childTileY,
        childTileZ = childCoordinates.childTileZ;

    var _rootBoundingVolume$r = (0, _slicedToArray2.default)(rootBoundingVolume.region, 6),
        west = _rootBoundingVolume$r[0],
        south = _rootBoundingVolume$r[1],
        east = _rootBoundingVolume$r[2],
        north = _rootBoundingVolume$r[3],
        minimumHeight = _rootBoundingVolume$r[4],
        maximumHeight = _rootBoundingVolume$r[5];

    var boundingVolumesCount = Math.pow(2, level);
    var sizeX = (east - west) / boundingVolumesCount;
    var sizeY = (north - south) / boundingVolumesCount;
    var sizeZ = (maximumHeight - minimumHeight) / boundingVolumesCount;
    var childWest = west + sizeX * childTileX,
        childEast = west + sizeX * (childTileX + 1);
    var childSouth = south + sizeY * childTileY,
        childNorth = south + sizeY * (childTileY + 1);
    var childMinimumHeight = minimumHeight + sizeZ * childTileZ,
        childMaximumHeight = minimumHeight + sizeZ * (childTileZ + 1);
    return {
      region: [childWest, childSouth, childEast, childNorth, childMinimumHeight, childMaximumHeight]
    };
  }

  console.warn('Unsupported bounding volume type: ', rootBoundingVolume);
  return null;
}

function concatBits(first, second) {
  return parseInt(first.toString(2) + second.toString(2), 2);
}

function replaceContentUrlTemplate(templateUrl, level, x, y, z) {
  var mapUrl = generateMapUrl({
    level: level,
    x: x,
    y: y,
    z: z
  });
  return templateUrl.replace(/{level}|{x}|{y}|{z}/gi, function (matched) {
    return mapUrl[matched];
  });
}

function generateMapUrl(items) {
  var mapUrl = {};

  for (var _key in items) {
    mapUrl["{".concat(_key, "}")] = items[_key];
  }

  return mapUrl;
}

function getBooleanValueFromBitstream(availabilityIndex, availabilityBuffer) {
  var byteIndex = Math.floor(availabilityIndex / 8);
  var bitIndex = availabilityIndex % 8;
  var bitValue = availabilityBuffer[byteIndex] >> bitIndex & 1;
  return bitValue === 1;
}
//# sourceMappingURL=parse-3d-implicit-tiles.js.map