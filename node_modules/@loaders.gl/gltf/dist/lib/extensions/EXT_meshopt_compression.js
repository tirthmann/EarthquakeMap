"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.decode = exports.preprocess = exports.name = void 0;
const gltf_scenegraph_1 = __importDefault(require("../api/gltf-scenegraph"));
const meshopt_decoder_1 = require("../../meshopt/meshopt-decoder");
// @ts-ignore
// eslint-disable-next-line
const DEFAULT_MESHOPT_OPTIONS = {
    byteOffset: 0,
    filter: 'NONE'
};
/** Extension name */
const EXT_MESHOPT_COMPRESSION = 'EXT_meshopt_compression';
exports.name = EXT_MESHOPT_COMPRESSION;
function preprocess(gltfData) {
    const scenegraph = new gltf_scenegraph_1.default(gltfData);
    if (scenegraph.getRequiredExtensions().includes(EXT_MESHOPT_COMPRESSION) &&
        !(0, meshopt_decoder_1.isMeshoptSupported)()) {
        throw new Error(`gltf: Required extension ${EXT_MESHOPT_COMPRESSION} not supported by browser`);
    }
}
exports.preprocess = preprocess;
async function decode(gltfData, options) {
    const scenegraph = new gltf_scenegraph_1.default(gltfData);
    if (!options?.gltf?.decompressMeshes) {
        return;
    }
    const promises = [];
    for (const bufferViewIndex of gltfData.json.bufferViews || []) {
        promises.push(decodeMeshoptBufferView(scenegraph, bufferViewIndex));
    }
    // Decompress meshes in parallel
    await Promise.all(promises);
    // We have now decompressed all primitives, so remove the top-level extensions
    scenegraph.removeExtension(EXT_MESHOPT_COMPRESSION);
}
exports.decode = decode;
/** Decode one meshopt buffer view */
async function decodeMeshoptBufferView(scenegraph, bufferView) {
    const meshoptExtension = scenegraph.getObjectExtension(bufferView, EXT_MESHOPT_COMPRESSION);
    if (meshoptExtension) {
        const buffer = bufferView.buffer;
        const { byteOffset = 0, byteLength = 0, byteStride, count, mode, filter = 'NONE' } = meshoptExtension;
        // @ts-expect-error TODO - fix buffer handling
        const source = new Uint8Array(buffer, byteOffset, byteLength);
        const result = new ArrayBuffer(count * byteStride);
        await (0, meshopt_decoder_1.meshoptDecodeGltfBuffer)(new Uint8Array(result), count, byteStride, source, mode, filter);
        return result;
    }
    return null;
}
