"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getLodStatus = getLodStatus;
exports.getProjectedRadius = getProjectedRadius;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _core = require("@math.gl/core");

var _geospatial = require("@math.gl/geospatial");

function getLodStatus(tile, frameState) {
  if (tile.lodMetricValue === 0 || isNaN(tile.lodMetricValue)) {
    return 'DIG';
  }

  var screenSize = 2 * getProjectedRadius(tile, frameState);

  if (screenSize < 2) {
    return 'OUT';
  }

  if (!tile.header.children || screenSize <= tile.lodMetricValue) {
    return 'DRAW';
  } else if (tile.header.children) {
    return 'DIG';
  }

  return 'OUT';
}

function getProjectedRadius(tile, frameState) {
  var originalViewport = frameState.viewport;
  var ViewportClass = originalViewport.constructor;
  var longitude = originalViewport.longitude,
      latitude = originalViewport.latitude,
      height = originalViewport.height,
      width = originalViewport.width,
      bearing = originalViewport.bearing,
      zoom = originalViewport.zoom;
  var viewport = new ViewportClass({
    longitude: longitude,
    latitude: latitude,
    height: height,
    width: width,
    bearing: bearing,
    zoom: zoom,
    pitch: 0
  });
  var mbsLat = tile.header.mbs[1];
  var mbsLon = tile.header.mbs[0];
  var mbsZ = tile.header.mbs[2];
  var mbsR = tile.header.mbs[3];
  var mbsCenterCartesian = (0, _toConsumableArray2.default)(tile.boundingVolume.center);
  var cameraPositionCartographic = viewport.unprojectPosition(viewport.cameraPosition);

  var cameraPositionCartesian = _geospatial.Ellipsoid.WGS84.cartographicToCartesian(cameraPositionCartographic, new _core.Vector3());

  var toEye = new _core.Vector3(cameraPositionCartesian).subtract(mbsCenterCartesian).normalize();
  var enuToCartesianMatrix = new _core.Matrix4();

  _geospatial.Ellipsoid.WGS84.eastNorthUpToFixedFrame(mbsCenterCartesian, enuToCartesianMatrix);

  var cartesianToEnuMatrix = new _core.Matrix4(enuToCartesianMatrix).invert();
  var cameraPositionEnu = new _core.Vector3(cameraPositionCartesian).transform(cartesianToEnuMatrix);
  var projection = Math.sqrt(cameraPositionEnu[0] * cameraPositionEnu[0] + cameraPositionEnu[1] * cameraPositionEnu[1]);
  var extraZ = projection * projection / cameraPositionEnu[2];
  var extraVertexEnu = new _core.Vector3([cameraPositionEnu[0], cameraPositionEnu[1], extraZ]);
  var extraVertexCartesian = extraVertexEnu.transform(enuToCartesianMatrix);
  var extraVectorCartesian = new _core.Vector3(extraVertexCartesian).subtract(mbsCenterCartesian).normalize();
  var radiusVector = toEye.cross(extraVectorCartesian).normalize().scale(mbsR);
  var sphereMbsBorderVertexCartesian = new _core.Vector3(mbsCenterCartesian).add(radiusVector);

  var sphereMbsBorderVertexCartographic = _geospatial.Ellipsoid.WGS84.cartesianToCartographic(sphereMbsBorderVertexCartesian);

  var projectedOrigin = viewport.project([mbsLon, mbsLat, mbsZ]);
  var projectedMbsBorderVertex = viewport.project(sphereMbsBorderVertexCartographic);
  var projectedRadius = new _core.Vector3(projectedOrigin).subtract(projectedMbsBorderVertex).magnitude();
  return projectedRadius;
}
//# sourceMappingURL=i3s-lod.js.map