{"version":3,"sources":["../../../../src/tileset/helpers/i3s-lod.ts"],"names":["Matrix4","Vector3","Ellipsoid","getLodStatus","tile","frameState","lodMetricValue","isNaN","screenSize","getProjectedRadius","header","children","originalViewport","viewport","ViewportClass","constructor","longitude","latitude","height","width","bearing","zoom","pitch","mbsLat","mbs","mbsLon","mbsZ","mbsR","mbsCenterCartesian","boundingVolume","center","cameraPositionCartographic","unprojectPosition","cameraPosition","cameraPositionCartesian","WGS84","cartographicToCartesian","toEye","subtract","normalize","enuToCartesianMatrix","eastNorthUpToFixedFrame","cartesianToEnuMatrix","invert","cameraPositionEnu","transform","projection","Math","sqrt","extraZ","extraVertexEnu","extraVertexCartesian","extraVectorCartesian","radiusVector","cross","scale","sphereMbsBorderVertexCartesian","add","sphereMbsBorderVertexCartographic","cartesianToCartographic","projectedOrigin","project","projectedMbsBorderVertex","projectedRadius","magnitude"],"mappings":"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","sourcesContent":["import {Matrix4, Vector3} from '@math.gl/core';\nimport {Ellipsoid} from '@math.gl/geospatial';\nimport Tile3D from '../tile-3d';\nimport {FrameState} from './frame-state';\n\n/**\n * For the maxScreenThreshold error metric, maxError means that you should replace the node with it's children\n   as soon as the nodes bounding sphere has a screen radius larger than maxError pixels.\n   In this sense a value of 0 means you should always load it's children,\n   or if it's a leaf node, you should always display it.\n * @param tile \n * @param frameState \n * @returns \n */\nexport function getLodStatus(tile: Tile3D, frameState: FrameState): 'DIG' | 'OUT' | 'DRAW' {\n  if (tile.lodMetricValue === 0 || isNaN(tile.lodMetricValue)) {\n    return 'DIG';\n  }\n  const screenSize = 2 * getProjectedRadius(tile, frameState);\n  if (screenSize < 2) {\n    return 'OUT';\n  }\n  if (!tile.header.children || screenSize <= tile.lodMetricValue) {\n    return 'DRAW';\n  } else if (tile.header.children) {\n    return 'DIG';\n  }\n  return 'OUT';\n}\n\n/**\n * Calculate size of MBS radius projected on the screen plane\n * @param tile\n * @param frameState\n * @returns\n */\n// eslint-disable-next-line max-statements\nexport function getProjectedRadius(tile: Tile3D, frameState: FrameState): number {\n  const originalViewport = frameState.viewport;\n  const ViewportClass = originalViewport.constructor;\n  const {longitude, latitude, height, width, bearing, zoom} = originalViewport;\n  // @ts-ignore\n  const viewport = new ViewportClass({longitude, latitude, height, width, bearing, zoom, pitch: 0});\n  const mbsLat = tile.header.mbs[1];\n  const mbsLon = tile.header.mbs[0];\n  const mbsZ = tile.header.mbs[2];\n  const mbsR = tile.header.mbs[3];\n  const mbsCenterCartesian = [...tile.boundingVolume.center];\n  const cameraPositionCartographic = viewport.unprojectPosition(viewport.cameraPosition);\n  const cameraPositionCartesian = Ellipsoid.WGS84.cartographicToCartesian(\n    cameraPositionCartographic,\n    new Vector3()\n  );\n\n  // ---------------------------\n  // Calculate mbs border vertex\n  // ---------------------------\n  const toEye = new Vector3(cameraPositionCartesian).subtract(mbsCenterCartesian).normalize();\n  // Add extra vector to form plane\n  const enuToCartesianMatrix = new Matrix4();\n  Ellipsoid.WGS84.eastNorthUpToFixedFrame(mbsCenterCartesian, enuToCartesianMatrix);\n  const cartesianToEnuMatrix = new Matrix4(enuToCartesianMatrix).invert();\n  const cameraPositionEnu = new Vector3(cameraPositionCartesian).transform(cartesianToEnuMatrix);\n  // Mean Proportionals in Right Triangles - Altitude rule\n  // https://mathbitsnotebook.com/Geometry/RightTriangles/RTmeanRight.html\n  const projection = Math.sqrt(\n    cameraPositionEnu[0] * cameraPositionEnu[0] + cameraPositionEnu[1] * cameraPositionEnu[1]\n  );\n  const extraZ = (projection * projection) / cameraPositionEnu[2];\n  const extraVertexEnu = new Vector3([cameraPositionEnu[0], cameraPositionEnu[1], extraZ]);\n  const extraVertexCartesian = extraVertexEnu.transform(enuToCartesianMatrix);\n  const extraVectorCartesian = new Vector3(extraVertexCartesian)\n    .subtract(mbsCenterCartesian)\n    .normalize();\n  // We need radius vector orthogonal to toEye vector\n  const radiusVector = toEye.cross(extraVectorCartesian).normalize().scale(mbsR);\n  const sphereMbsBorderVertexCartesian = new Vector3(mbsCenterCartesian).add(radiusVector);\n  const sphereMbsBorderVertexCartographic = Ellipsoid.WGS84.cartesianToCartographic(\n    sphereMbsBorderVertexCartesian\n  );\n  // ---------------------------\n\n  // Project center vertex and border vertex and calculate projected radius of MBS\n  const projectedOrigin = viewport.project([mbsLon, mbsLat, mbsZ]);\n  const projectedMbsBorderVertex = viewport.project(sphereMbsBorderVertexCartographic);\n  const projectedRadius = new Vector3(projectedOrigin)\n    .subtract(projectedMbsBorderVertex)\n    .magnitude();\n  return projectedRadius;\n}\n"],"file":"i3s-lod.js"}