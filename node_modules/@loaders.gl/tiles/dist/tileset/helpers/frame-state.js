"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getFrameState = void 0;
const core_1 = require("@math.gl/core");
const culling_1 = require("@math.gl/culling");
const geospatial_1 = require("@math.gl/geospatial");
const scratchVector = new core_1.Vector3();
const scratchPosition = new core_1.Vector3();
const cullingVolume = new culling_1.CullingVolume([
    new culling_1.Plane(),
    new culling_1.Plane(),
    new culling_1.Plane(),
    new culling_1.Plane(),
    new culling_1.Plane(),
    new culling_1.Plane()
]);
// Extracts a frame state appropriate for tile culling from a deck.gl viewport
// TODO - this could likely be generalized and merged back into deck.gl for other culling scenarios
function getFrameState(viewport, frameNumber) {
    // Traverse and and request. Update _selectedTiles so that we know what to render.
    const { cameraDirection, cameraUp, height } = viewport;
    const { metersPerUnit } = viewport.distanceScales;
    const viewportCenterCartographic = viewport.unprojectPosition(viewport.center);
    // TODO - Ellipsoid.eastNorthUpToFixedFrame() breaks on raw array, create a Vector.
    // TODO - Ellipsoid.eastNorthUpToFixedFrame() takes a cartesian, is that intuitive?
    const viewportCenterCartesian = geospatial_1.Ellipsoid.WGS84.cartographicToCartesian(viewportCenterCartographic, new core_1.Vector3());
    const enuToFixedTransform = geospatial_1.Ellipsoid.WGS84.eastNorthUpToFixedFrame(viewportCenterCartesian);
    const cameraPositionCartographic = viewport.unprojectPosition(viewport.cameraPosition);
    const cameraPositionCartesian = geospatial_1.Ellipsoid.WGS84.cartographicToCartesian(cameraPositionCartographic, new core_1.Vector3());
    // These should still be normalized as the transform has scale 1 (goes from meters to meters)
    const cameraDirectionCartesian = new core_1.Vector3(
    // @ts-ignore
    enuToFixedTransform.transformAsVector(new core_1.Vector3(cameraDirection).scale(metersPerUnit))).normalize();
    const cameraUpCartesian = new core_1.Vector3(
    // @ts-ignore
    enuToFixedTransform.transformAsVector(new core_1.Vector3(cameraUp).scale(metersPerUnit))).normalize();
    commonSpacePlanesToWGS84(viewport, viewportCenterCartesian);
    // TODO: make a file/class for frameState and document what needs to be attached to this so that traversal can function
    return {
        camera: {
            position: cameraPositionCartesian,
            direction: cameraDirectionCartesian,
            up: cameraUpCartesian
        },
        viewport,
        height,
        cullingVolume,
        frameNumber,
        sseDenominator: 1.15 // Assumes fovy = 60 degrees
    };
}
exports.getFrameState = getFrameState;
function commonSpacePlanesToWGS84(viewport, viewportCenterCartesian) {
    // Extract frustum planes based on current view.
    const frustumPlanes = viewport.getFrustumPlanes();
    let i = 0;
    for (const dir in frustumPlanes) {
        const plane = frustumPlanes[dir];
        const distanceToCenter = plane.normal.dot(viewport.center);
        scratchPosition
            .copy(plane.normal)
            .scale(plane.distance - distanceToCenter)
            .add(viewport.center);
        const cartographicPos = viewport.unprojectPosition(scratchPosition);
        const cartesianPos = geospatial_1.Ellipsoid.WGS84.cartographicToCartesian(cartographicPos, new core_1.Vector3());
        cullingVolume.planes[i++].fromPointNormal(cartesianPos, 
        // Want the normal to point into the frustum since that's what culling expects
        scratchVector.copy(viewportCenterCartesian).subtract(cartesianPos));
    }
}
