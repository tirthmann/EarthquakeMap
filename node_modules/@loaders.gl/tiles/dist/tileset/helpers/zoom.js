"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getZoomFromBoundingVolume = void 0;
const core_1 = require("@math.gl/core");
const culling_1 = require("@math.gl/culling");
const WGS84_RADIUS_X = 6378137.0;
const WGS84_RADIUS_Y = 6378137.0;
const WGS84_RADIUS_Z = 6356752.3142451793;
const scratchVector = new core_1.Vector3();
/**
 * Calculate appropriate zoom value for a particular boundingVolume
 * @param boundingVolume - the instance of bounding volume
 * @param cartorgraphicCenter - cartographic center of the bounding volume
 * @returns {number} - zoom value
 */
function getZoomFromBoundingVolume(boundingVolume, cartorgraphicCenter) {
    if (boundingVolume instanceof culling_1.OrientedBoundingBox) {
        // OrientedBoundingBox
        const { halfAxes } = boundingVolume;
        const obbSize = getObbSize(halfAxes);
        // Use WGS84_RADIUS_Z to allign with BoundingSphere algorithm
        // Add the tile elevation value for correct zooming to elevated tiles
        return Math.log2(WGS84_RADIUS_Z / (obbSize + cartorgraphicCenter[2]));
    }
    else if (boundingVolume instanceof culling_1.BoundingSphere) {
        // BoundingSphere
        const { radius } = boundingVolume;
        // Add the tile elevation value for correct zooming to elevated tiles
        return Math.log2(WGS84_RADIUS_Z / (radius + cartorgraphicCenter[2]));
    }
    else if (boundingVolume.width && boundingVolume.height) {
        // BoundingRectangle
        const { width, height } = boundingVolume;
        const zoomX = Math.log2(WGS84_RADIUS_X / width);
        const zoomY = Math.log2(WGS84_RADIUS_Y / height);
        return (zoomX + zoomY) / 2;
    }
    return 1;
}
exports.getZoomFromBoundingVolume = getZoomFromBoundingVolume;
function getObbSize(halfAxes) {
    halfAxes.getColumn(0, scratchVector);
    const axeY = halfAxes.getColumn(1);
    const axeZ = halfAxes.getColumn(2);
    const farthestVertex = scratchVector.add(axeY).add(axeZ);
    const size = farthestVertex.len();
    return size;
}
